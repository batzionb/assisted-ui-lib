import {
  HostConfiguration,
  StaticFormData,
  StaticIpView,
  StaticIpValues,
  StaticNetworkWideConfigurations,
  ProtocolVersion,
} from './types';
import { HostStaticNetworkConfig, InfraEnv, MacInterfaceMap, stringToJSON } from '../../common';
import { StaticIpNetworkWideConfigurations } from '../components/clusterConfiguration/staticIp/StaticIpNetworkWideConfigurations';
import { StaticIpInfo } from './types';
import {
  formHostDataToYamlStr,
  getCommonPrefix,
  showIpv4,
  showIpv6,
} from './StaticIpFormHostToYaml';

const getEmptyAddressData = () => {
  return {
    dns: '',
    gateway: '',
    subnet: '',
  };
};

const getEmptyFormHost = (): HostConfiguration => {
  return {
    macAddress: '',
    ipv4Address: '',
    ipv6Address: '',
  };
};

const emptyFormConfig: StaticFormData = {
  networWideConfigurations: {
    ipv4: {
      dns: '',
      gateway: '',
      subnet: '',
    },
    ipv6: {
      dns: '',
      gateway: '',
      subnet: '',
    },
    protocolType: 'ipv4',
    useVlan: false,
    vlanId: '',
  },
  hostConfigurations: [getEmptyFormHost()],
};

const dummyYamlPrefix = '#dummy configuration generated by ui';
const formViewPrefix = '#generated by ui form view';
const dummyNic = 'dummyNic';
const dummyNmstateYaml = `${dummyYamlPrefix};
interfaces:
- ipv4:
    address:
    - ip: 192.168.126.30
      prefix-length: 24
    dhcp: false
    enabled: true
  name: ${dummyNic}
  state: up
  type: ethernet
`;
const dummyFormViewNetworkYaml = `${formViewPrefix}
#${JSON.stringify(emptyFormConfig)}
${dummyNmstateYaml}`;

const dummyMacInterfaceMap: MacInterfaceMap = [
  { macAddress: '01:23:45:67:89:AB', logicalNicName: dummyNic },
];

const emptyYamlConfig: HostStaticNetworkConfig = {
  networkYaml: '',
  macInterfaceMap: [{ macAddress: '', logicalNicName: '' }],
};

const getViewFromNetworkYaml = (networkYaml: string): StaticIpView => {
  if (networkYaml.startsWith(formViewPrefix)) {
    return StaticIpView.FORM;
  } else {
    return StaticIpView.YAML;
  }
};

const clearValues = (values: StaticIpValues): void => {
  values.formData = emptyFormConfig;
  values.yamlData = [emptyYamlConfig];
};

const getEmptyFormData = (): StaticFormData => {
  return emptyFormConfig;
};

const getNewFormHost = (
  networkWideConfiguration: StaticNetworkWideConfigurations,
): HostConfiguration => {
  return getEmptyFormHost();
};

const StaticIpDataService = {
  getDummyValidValue(configType = StaticIpView.FORM): HostStaticNetworkConfig[] {
    //staticNetworkConfig infraEnv field doesn't support an empty value so a dummy value is assigned
    if (configType === StaticIpView.FORM) {
      return [
        {
          networkYaml: dummyFormViewNetworkYaml,
          macInterfaceMap: dummyMacInterfaceMap,
        },
      ];
    }
    return [
      {
        networkYaml: dummyNmstateYaml,
        macInterfaceMap: dummyMacInterfaceMap,
      },
    ];
  },

  getEmptyStaticIpValues(configType = StaticIpView.FORM): StaticIpValues {
    return {
      configType,
      formData: emptyFormConfig,
      yamlData: [emptyYamlConfig],
    };
  },

  getView(staticNetworkConfig: HostStaticNetworkConfig[] | undefined): StaticIpView | null {
    if (!staticNetworkConfig) {
      return null;
    }
    if (
      staticNetworkConfig.length < 1 ||
      !staticNetworkConfig[0].macInterfaceMap ||
      !staticNetworkConfig[0].networkYaml
    ) {
      throw `Static network config isn't valid`;
    }
    const networkYaml = staticNetworkConfig[0].networkYaml;
    if (networkYaml.startsWith(formViewPrefix)) {
      return StaticIpView.FORM;
    } else {
      return StaticIpView.YAML;
    }
  },

  getInfraEnvStaticIpView(infraEnv: InfraEnv): StaticIpView | null {
    if (!infraEnv.staticNetworkConfig) {
      return null;
    }
    const staticNetworkConfig = stringToJSON<HostStaticNetworkConfig[]>(
      infraEnv.staticNetworkConfig,
    );
    return StaticIpDataService.getView(staticNetworkConfig);
  },

  getStaticIpValues(staticNetworkConfigStr: string): StaticIpValues {
    const staticNetworkConfig = stringToJSON<HostStaticNetworkConfig[]>(staticNetworkConfigStr);
    if (!staticNetworkConfig) {
      throw 'Failed to parse static ip data';
    }
    if (
      staticNetworkConfig.length < 1 ||
      !staticNetworkConfig[0].macInterfaceMap ||
      !staticNetworkConfig[0].networkYaml
    ) {
      throw `Static network config isn't valid`;
    }
    const networkYaml = staticNetworkConfig[0].networkYaml;
    const view = getViewFromNetworkYaml(networkYaml);
    const values: StaticIpValues = {
      configType: view,
      formData: emptyFormConfig,
      yamlData: [emptyYamlConfig],
    };
    if (networkYaml.startsWith(formViewPrefix)) {
      const yamlLines = networkYaml.split('\n');
      const formDataJsonComment = yamlLines[1];
      const commentIdx = formDataJsonComment.indexOf('#');
      const formDataJsonString = formDataJsonComment.substring(commentIdx + 1);
      values.formData = JSON.parse(formDataJsonString);
    } else if (!networkYaml.startsWith(dummyYamlPrefix)) {
      values.yamlData = staticNetworkConfig;
    }
    return values;
  },

  isDummyYamlData(yamlData: HostStaticNetworkConfig[]): boolean {
    return (
      yamlData.length === 1 &&
      !!yamlData[0].networkYaml &&
      yamlData[0].networkYaml.indexOf(dummyYamlPrefix) > -1
    );
  },

  formDataToHostStaticNetworkConfig(formData: StaticFormData): HostStaticNetworkConfig[] {
    let ret: HostStaticNetworkConfig[] = [];
    if (
      formData.hostConfigurations.length === 1 &&
      formData.hostConfigurations[0].macAddress === ''
    ) {
      //user only filled in network wide configuration and didn't fill in host specific configurations
      ret = [
        {
          networkYaml: dummyNmstateYaml,
          macInterfaceMap: dummyMacInterfaceMap,
        },
      ];
    } else {
      for (const host of formData.hostConfigurations) {
        const nicName = 'eth0';
        ret.push({
          networkYaml: formHostDataToYamlStr(formData.networWideConfigurations, host, nicName),
          macInterfaceMap: [
            {
              macAddress: host.macAddress,
              logicalNicName: nicName,
            },
          ],
        });
      }
    }

    //add form data to first host yaml
    ret[0].networkYaml = `${formViewPrefix}\n#${JSON.stringify(formData)}\n${ret[0].networkYaml}`;
    return ret;
  },

  getStaticNetworkConfigUpdateValue(values: StaticIpValues): HostStaticNetworkConfig[] | undefined {
    if (values.configType === StaticIpView.FORM && values.formData) {
      return StaticIpDataService.formDataToHostStaticNetworkConfig(values.formData);
    } else {
      return values.yamlData;
    }
  },

  getEmptyHostYamlData(): HostStaticNetworkConfig {
    return emptyYamlConfig;
  },

  getEmptyYamlData(): HostStaticNetworkConfig[] {
    return [emptyYamlConfig];
  },

  isValidStaticIp(infraEnv: InfraEnv): boolean {
    if (!infraEnv.staticNetworkConfig) {
      return false;
    }
    const staticNetworkConfg = stringToJSON<HostStaticNetworkConfig[]>(
      infraEnv.staticNetworkConfig,
    );
    if (!staticNetworkConfg) {
      return false;
    }
    return !StaticIpDataService.isDummyYamlData(staticNetworkConfg);
  },

  getStaticIpInfo(infraEnv: InfraEnv): StaticIpInfo | null {
    if (!infraEnv.staticNetworkConfig) {
      return null;
    }
    const staticNetworkConfg = stringToJSON<HostStaticNetworkConfig[]>(
      infraEnv.staticNetworkConfig,
    );
    if (!staticNetworkConfg || !staticNetworkConfg.length) {
      return null;
    }
    const view = StaticIpDataService.getView(staticNetworkConfg);
    if (view === null) {
      return null;
    }
    if (!staticNetworkConfg[0].networkYaml) {
      return null;
    }
    return {
      view: getViewFromNetworkYaml(staticNetworkConfg[0].networkYaml),
      isDataComplete: !StaticIpDataService.isDummyYamlData(staticNetworkConfg),
    };
  },
  getNewFormHost,
  getEmptyAddressData,
  getEmptyFormHost,
  clearValues,
  getEmptyFormData,
};

export default StaticIpDataService;
